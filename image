#!/bin/bash
#
# Overwrite a device (or file) with an image file.  Minimize code run as root.
# Show progress.  Attempt to fail if the output target is mounted or otherwise
# in use.
#
# WARNING:  Detection of usage of the output target can fail.  There are a
# number of ways to be in use, and checking all of them may be impossible.  The
# policy of running as much code as possible as non-root may lead to more cases
# where detection fails.  Even if detection is perfect, there is still a race
# condition.  
# 
# The idea is that this script should stop you (me) from accidentally imaging
# the OS disk instead of a USB device on a single user desktop, especially when
# those targets have similar names, ie when the ordering of /dev/sda and
# /dev/sdb depend on whether you had a USB stick plugged in at boot time.  That
# case should fairly well handled, but you should still try to target the right
# device.  If your system is complex, multi-user, and/or unusually configured,
# unhandled problems are more likely, but the script should still be safer than
# just blasting the target with dd.
#
# It's like a safety net.  There are big holes, but I still feel better with it
# than without it.


# TODO:  Test intended failure conditions.

# TODO:  Research how effective it is to obtain a lock on a device file and
# whether this might remove the need for some other checking.

# TODO:  Handle lack of read permissions for readlink.  Maybe write a wrapper
# function.

# TODO:  Fail if output the target is the subject of an ongoing direct read or
# write operation.

# TODO:  Decide whether to check whether arguments refer to extant files.

# TODO:  Research whether device mapper interacts directly with non-device
# files.  Adjust comments in check_device_mapper().

# TODO:  Fail if information gathering commands fail.  Determine how to make
# that happen when they run in sub-shells.


shopt -s nullglob


function main() {
  input="${1}"
  output="$(readlink -m "${2}")"
  num_args=2

  check_tools

  # Checking that arguments are non-empty and/or refer to files that exist may
  # be good, or may be redundant.
  check_args "${@}"

  output "Input file:  ${input}"
  output "Output file:  ${output}"

  # Checking whether the output (device) file is in use would definitely be
  # wise, but may not be simple.  Discussion:
  #
  #   https://unix.stackexchange.com/questions/111779/
  check_output_safety

  bs="$(( 1024 * 1024 ))"
  size="$(stat -c '%s' "${input}")"

  sudo -v

  dd bs="${bs}" if="${input}" \
  | pv -B "$(( bs * 2 ))" -praetkfs "${size}" \
  | sudo dd oflag=sync bs="${bs}" of="${output}"
}


function check_tools() {
  tools=(
    sudo
    dd
    pv
    readlink
    grep
    df
    mount
    swapon
    losetup
    lsblk
  )

  for tool in "${tools[@]}"; do
    tools_present='yes'
    if ! type "${tool}" > /dev/null 2>&1; then
      tools_present='no'
      warn "Required not found:  '${tool}'"
    fi
    if ! test 'yes' = "${tools_present}"; then
      fail "Required tools not all found."
    fi
  done
}


function check_args() {
  if ! test "${num_args}" = "${#}"; then
    usage
    fail "Wrong number of arguments.  Expected:  ${num_args}.  Received:  ${#}."
  fi
  if ! test -e "${input}"; then
    fail "Input file does not exist."
  fi
  if ! test -e "${output}"; then
    warn "Output file does not exist."
  fi
}


function check_output_safety() {
  output_parts=( "${output}" )
  while read output_part; do
    output_parts+=( "${output_part}" )
  done < <(lsblk -lnpo name "${output}")
  check_fstab 
  check_mounts 
  check_swap
  check_device_mapper 
  check_loopback
}


function find_label() {
  label=
  for label_link in /dev/disk/by-label/*; do
    label_target="$(readlink -m "${label_link}")"
    if test "${output}" = "${label_target}"; then
      if ! test '' = "${label}"; then
        warn "Multiple labels found.  Ignoring label:  '${label}'"
      fi
      label="${label_link##*/}"
    fi
  done

  printf '%s\n' "${label}"
}


function find_uuid() {
  uuid=
  for uuid_link in /dev/disk/by-uuid/*; do
    uuid_target="$(readlink -m "${uuid_link}")"
    if test "${output}" = "${uuid_target}"; then
      if ! test '' = "${uuid}"; then
        warn "Multiple uuids found.  Ignoring uuid:  '${uuid}'"
      fi
      uuid="${uuid_link##*/}"
    fi
  done

  printf '%s\n' "${uuid}"
}


function check_fstab() {
  # This will not notice an fstab entry referring to the output target using a
  # different string.  One example is a symlink to a device file.  Another
  # example is backslash escape codes for characters.
  #
  # This may be an acceptable level of risk if currently mounted volumes will
  # still be noticed.
  for output_part in "${output_parts[@]}"; do
    label="$(find_label "${output_part}")"
    uuid="$(find_uuid "${output_part}")"

    if grep -q "^[[:space:]]*${output_part}[[:space:]]" /etc/fstab; then
      fail "Output target or partition or subvolume ('${output_part}') is specified in:  /etc/fstab"
    fi

    if grep -q "^[[:space:]]*UUID=${uuid}[[:space:]]" /etc/fstab; then
      fail "UUID ('${uuid}') is specified in:  /etc/fstab"
    fi

    if grep -q "^[[:space:]]*LABEL=${label}[[:space:]]" /etc/fstab; then
      fail "Label ('${label}') is specified in:  /etc/fstab"
    fi
  done
}


check_mounts() {
  # Carefully avoid problems with symlinks and whitespace.
  while read volume_entry; do
    volume="$(readlink -m "${volume_entry}")"
    for output_part in "${output_parts[@]}"; do
      if test "${volume}" = "${output_part}"; then
        fail "Output target or partition or subvolume ('${output_part}') is mounted."
      fi
    done
  done < <(df -l --output=source)
}


check_swap() {
  # Carefully avoid problems with symlinks and whitespace.
  while read swap_entry; do
    swap="$(readlink -m "${swap_entry}")"
    for output_part in "${output_parts[@]}"; do
      if test "${swap}" = "${output_part}"; then
        fail "Output target or partition or subvolume is in use as swap."
      fi
    done
  done < <(swapon --noheadings --show=name)
}


function check_device_mapper() {
  # This may not notice device mapper holds on non-device files.  This may be
  # acceptable if (1) device mapper only interacts with non-device files
  # through loopback device files, and (2) use of a non-device file as backing
  # for a loopback device file will be noticed.
  for output_part in "${output_parts[@]}"; do
    if grep -q '^/dev/' <<< "${output_part}"; then
      # Wildcards should facilitate checking both devices and partitions.
      for hold in /sys/block/{,*/}"${output_part##*/}"/{,*/}holders/*; do
        fail "Output target is held by device mapper."
      done
    fi
  done
}


function check_loopback() {
  # Carefully avoid problems with symlinks and whitespace.

  while read loop_entry; do
    loop="$(readlink -m "${loop_entry}")"
    for output_part in "${output_parts[@]}"; do
      if test "${loop}" = "${output_part}"; then
        fail "Output target or partition or subvolume ('${output_part}') backs a loopback device file:  '${loop_entry}'"
      fi
    done
  done < <(losetup -n -O back-file)
}


function output() {
  printf '%s\n' "${1}"
}


function warn() {
  output "Warning:  ${1}" >&2
}


function fail() {
  output "Error:  ${1}" >&2
  exit "${2:-1}"
}


function usage() {
  output "image <input_file> <output_file>"
  output ""
  output "Example:"
  output "  image image.iso /dev/sda"
}


main "${@}"
